delta_x = 0.1
delta_y = 0.1
delta_z = 0.1

delta_t = 0.1

NX = 100
NY = 100
NZ = 100

/*
各項が「自由変数は何か」「自由変数はどのような範囲を取れるか」を知っていればいい。

i : i in any
i + j : (i,j) in [0..99] * [0..99]
phi : (prefix, postfix, [1]) in ([dens_,rhot_] * [[]] * [0..99]) + ([mom_] * [_x] * [1/2..98+1/2])
dens_phi : {[1] => [0..99]}
mom_phi  : {postfix => _x, [1] => [0..99]}

mom_phi[i]  : {postfix => _x, i => [0..99]}



*/

system phi
  forall (i in [0..NX], j in [0..NY], k in [0..NZ])
    dens_phi[i,j,k]
    rhot_phi[i,j,k]
  end forall
  forall (i in [1/2..NX-1/2], j in [0..NY], k in [0..NZ])
    mom_phi_x[i,j,k]
  end forall
  forall (i in [0..NX], j in [1/2..NY-1/2], k in [0..NZ])
    mom_phi_y[i,j,k]
  end forall
  forall (i in [0..NX], j in [0..NY], k in [1/2..NZ-1/2])
    mom_phi_z[i,j,k]
  end forall
end define


/*

partial = {postfix => [x,y,z], apply => any, [,,]}



*/

define partial
forall (a, i, j, k)
  partial_x(a)[i,j,k] = (a[i+1/2,j,k] - a[i-1/2,j,k]) / delta_x
  partial_y(a)[i,j,k] = (a[i,j+1/2,k] - a[i,j-1/2,k]) / delta_y
  partial_z(a)[i,j,k] = (a[i,j,k+1/2] - a[i,j,k-1/2]) / delta_z
end forall
end define




forall (a, d in [x,y,z])
  grad(a)_d = partial_d(a)
end forall

forall (a)
  div(a) = partial_x(a_x) +  partial_y(a_y) +  partial_z(a_z)
end forall

/*

この式自体は任意のi,j,kに対してマッチする。
  interpolate2_x(a)[i,j,k] = (a[i+1/2,j,k] + a[i-1/2,j,k]) / 2
    (a[i+1/2,j,k] + a[i-1/2,j,k]) / 2 : { i => any, j => any, k => any}

dens_bar[i,j,k]
 = (dens_phi[i+1/2,j,k] + dens_phi[i-1/2,j,k]) / 2



やはりHonu流のQuoteは必要！
newRho[i,j,k] = solve(k, f[i,j,k], c[i,j,k])


おそらくアトムを演算する式とそうでない式があって、ハッシュ指向が介入するのはアトムを操作するところだけ。
ハッシュ指向と穴指向の整合性は？穴指向だけでいけるか？

*/

forall (a,i,j,k)
  interpolate2_x(a)[i,j,k] = (a[i+1/2,j,k] + a[i-1/2,j,k]) / 2
  interpolate2_y(a)[i,j,k] = (a[i,j+1/2,k] + a[i,j-1/2,k]) / 2
  interpolate2_z(a)[i,j,k] = (a[i,j,k+1/2] + a[i,j,k-1/2]) / 2
  interpolate4_x(a)[i,j,k] = (-a[i+3/2,j,k] + 7*a[i+1/2,j,k] + 7*a[i-1/2,j,k] - a[i-3/2,j,k]) / 12
  interpolate4_y(a)[i,j,k] = (-a[i,j+3/2,k] + 7*a[i,j+1/2,k] + 7*a[i,j-1/2,k] - a[i,j-3/2,k]) / 12
  interpolate4_z(a)[i,j,k] = (-a[i,j,k+3/2] + 7*a[i,j,k+1/2] + 7*a[i,j,k-1/2] - a[i,j,k-3/2]) / 12
end forall


forall (a, n in Rational)
  (a<<(x,n))[i,j,k] = a[i+n,j,k]
  (a<<(y,n))[i,j,k] = a[i,j+n,k]
  (a<<(z,n))[i,j,k] = a[i,j,k+n]
end forall

forall (i,j,k)
  init_dens[i,j,k] = exp(- k * delta_z / 50)
  init_rhot[i,j,k] = 273 - k * delta_z / 10
  init_mom_x[i,j,k] = 0
  init_mom_y[i,j,k] = 0
  init_mom_z[i,j,k] = 0
end forall

forall (s)
  step(s) = rk4(step1, s)
end forall

forall (op,phi)
  rk4(op, phi) = phi4

    here

  phi1 = phi + 1/4 * op(phi)
  phi2 = phi + 1/3 * op(phi1)
  phi3 = phi + 1/2 * op(phi2)
  phi4 = phi +       op(phi3)
end forall

forall (current)
  step1(current) = next

    here

  pres = p00 * (current_rhot * rstar / p00) ** (cpstar / (cpstar - rstar))
  pott = current_rhot / current_dens


  forall (i in Integer, j in Integer, k in Integer)
    rhoBar[i+1/2,j,k] = interpolate2_x(dens_phi)[i+1/2,j,k]
    rhoBar[i,j+1/2,k] = interpolate2_y(dens_phi)[i,j+1/2,k]
    rhoBar[i,j,k+1/2] = interpolate2_z(dens_phi)[i,j,k+1/2]
  end forall

  forall (i in Integer, j in Integer, k in Integer)
    pottBar[i+1/2,j,k] = interpolate4_x(pott)[i+1/2,j,k]
    pottBar[i,j+1/2,k] = interpolate4_y(pott)[i,j+1/2,k]
    pottBar[i,j,k+1/2] = interpolate4_z(pott)[i,j,k+1/2]
  end forall

  forall (i in Integer, j in Integer, k in Integer, d in [x,y,z])
    momBar_d[i+1/2,j,k] = interpolate4_d(mom_d)
  end forall

  forall (i, j, k, d in [x,y,z])
    vBar_d = current_mom_d[i,j,k] / rhoBar
    vFull_d = interpolate2_d(mom_d) / rho
  end forall

  ddt_dens = - div(mom)

  forall (d in [x,y,z])
    ddt_mom_d  = - div(momBar_d * vBar) - grad pres
  end forall

  ddt_rhot = -div(mom * pottBar)


  next_dens = ddt_dens * delta_t
  next_mom  = ddt_mom  * delta_t
  next_rhot = ddt_rhot * delta_t
end forall
