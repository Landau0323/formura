dens_phi[i,j,k] : i in [0..99] , j in [0..99], k in [0..99]
mom_phi_x[i,j,k]:
mom_phi_y[i,j,k]:
mom_phi_z[i,j,k]:
rhot_phi[i,j,k] :

# まずstep1(phi)が呼び出される。
pott = rhot_phi / dens_phi

このとき何も起こらない、というのは選択肢の1つ。だけど、eagerの方が楽である、という原則に従うと、ここでpottが決まって欲しい。

pott : waits [i,j,k] : i in  [0..99] , j in [0..99], k in [0..99]

forall i in Integer,j in Integer,k in Integer
    rhoBar[i+1/2,j,k] = interpolate2_x(dens_phi)[i+1/2,j,k]

左辺を正規形にします
forall i in Integer-1/2,j in Integer,k in Integer
    rhoBar[i,j,k] = interpolate2_x(dens_phi)[i,j,k]


    rhoBar[a,b,c] = (dens_phi[a+1/2,b,c] + dens_phi[a-1/2,b,c]

ここで

# dens_phi[i,j,k] : i in [0..99] , j in [0..99], k in [0..99]

を参照して、アルファ変換を施す

dens_phi[a+1/2,b,c] : (a+1/2) in [0..99] , b in [0..99], c in [0..99]

型部分を簡約

dens_phi[a+1/2,b,c] : (a) in [0-1/2..99-1/2] , b in [0..99], c in [0..99]

同様に

dens_phi[a-1/2,b,c] : (a) in [0+1/2..99+1/2] , b in [0..99], c in [0..99]



## 集中的な考察

for (i,j,k)
  dens[i,j,k] = sin(i) * j * k
  rhot[i,j,k] = sin(i) + j + k
end for
# このときdensが、「[expr,expr,expr]を受け取って左辺式を返すもの」になる。

mom = dens + rhot
# このときはー＞パーザー同士の加算がEagerに発動.
「[expr,expr,expr]にマッチして、受け取ったものを両辺に渡しつつ返り値を加算して返す。」

for (i,j,k)
  ret[i,j,k] = mom[i,j,k-1] + dens[i,j,k+1]
