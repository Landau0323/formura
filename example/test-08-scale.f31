# 空間、時間刻みの定義
delta_x = 0.1
delta_y = 0.1
delta_z = 0.1
delta_t = 0.1

# 解像度の定義
nx = 100
ny = 100
nz = 100

# システムの独立変数の定義
define system(s)
  forall (i in [0..NX], j in [0..NY], k in [0..NZ])
    s_dens[i,j,k] # 密度
    s_rhot[i,j,k] # 温度ポテンシャル
  end forall
  forall (i in [1/2..NX-1/2], j in [0..NY], k in [0..NZ])
    s_mom_x[i,j,k] # 運動量のx成分
  end forall
  forall (i in [0..NX], j in [1/2..NY-1/2], k in [0..NZ])
    s_mom_y[i,j,k] # 運動量のy成分
  end forall
  forall (i in [0..NX], j in [0..NY], k in [1/2..NZ-1/2])
    s_mom_z[i,j,k] # 運動量のz成分
  end forall
end define

################################################################
# ライブラリ
################################################################
# 偏微分演算子
forall (a, i, j, k)
  partial_x(a)[i,j,k] = (a[i+1/2,j,k] - a[i-1/2,j,k]) / delta_x
  partial_y(a)[i,j,k] = (a[i,j+1/2,k] - a[i,j-1/2,k]) / delta_y
  partial_z(a)[i,j,k] = (a[i,j,k+1/2] - a[i,j,k-1/2]) / delta_z
end forall

# グラジエント演算子
forall (a, d in [x,y,z])
  grad(a)_d = partial_d(a)
end forall

# ダイバージェンス演算子
forall (a)
  div(a) = partial_x(a_x) +  partial_y(a_y) +  partial_z(a_z) 
end forall

# 2次と4次の補間関数の定義
forall (a,i,j,k)
  interpolate2_x(a)[i,j,k] = (a[i+1/2,j,k] + a[i-1/2,j,k]) / 2
  interpolate2_y(a)[i,j,k] = (a[i,j+1/2,k] + a[i,j-1/2,k]) / 2
  interpolate2_z(a)[i,j,k] = (a[i,j,k+1/2] + a[i,j,k-1/2]) / 2
  interpolate4_x(a)[i,j,k] = (-a[i+3/2,j,k] + 7*a[i+1/2,j,k] + 7*a[i-1/2,j,k] - a[i-3/2,j,k]) / 12
  interpolate4_y(a)[i,j,k] = (-a[i,j+3/2,k] + 7*a[i,j+1/2,k] + 7*a[i,j-1/2,k] - a[i,j-3/2,k]) / 12
  interpolate4_z(a)[i,j,k] = (-a[i,j,k+3/2] + 7*a[i,j,k+1/2] + 7*a[i,j,k-1/2] - a[i,j,k-3/2]) / 12
end forall

# 配列をずらす演算子の定義(今回は使ってない)
forall (a, n in Rational)
  (a<<(x,n))[i,j,k] = a[i+n,j,k]
  (a<<(y,n))[i,j,k] = a[i,j+n,k]
  (a<<(z,n))[i,j,k] = a[i,j,k+n]
end forall

################################################################
# 流体力学ソルバの実装
################################################################

# 初期条件
forall (i,j,k)
  init_dens[i,j,k] = exp(- k * delta_z / 50)
  init_rhot[i,j,k] = 273 - k * delta_z / 10
  init_mom_x[i,j,k] = 0
  init_mom_y[i,j,k] = 0
  init_mom_z[i,j,k] = 0
end forall

# 時間発展関数
forall (s)
  step(s) = rk4(step1, s)
end forall

# 4次の「ルンゲクッタ法」の定義
forall (op,phi)
  rk4(op, phi) = phi4

    where

  phi1 = phi + 1/4 * op(phi)
  phi2 = phi + 1/3 * op(phi1)
  phi3 = phi + 1/2 * op(phi2)
  phi4 = phi +       op(phi3)
end forall

# 1次の時間発展オペレータの定義
# 現在の状態(current) から次の状態(next)を求める
forall (current)
  step1(current) = next

    where
  
  pres = p00 * (current_rhot * rstar / p00) ** (cpstar / (cpstar - rstar))
  pott = current_rhot / current_dens


  forall (i in Integer, j in Integer, k in Integer) 
    rhoBar[i+1/2,j,k] = interpolate2_x(rho)
    rhoBar[i,j+1/2,k] = interpolate2_y(rho) 
    rhoBar[i,j,k+1/2] = interpolate2_z(rho) 
  end forall

  forall (i in Integer, j in Integer, k in Integer) 
    pottBar[i+1/2,j,k] = interpolate4_x(pott)
    pottBar[i,j+1/2,k] = interpolate4_y(pott) 
    pottBar[i,j,k+1/2] = interpolate4_z(pott) 
  end forall

  forall (i in Integer, j in Integer, k in Integer, d in [x,y,z]) 
    momBar_d[i+1/2,j,k] = interpolate4_d(mom_d)
  end forall

  forall (d in [x,y,z])
    vBar_d = current_mom_d / rhoBar
    vFull_d = interpolate2_d(mom_d) / rho
  end forall

  ddt_dens = - div(mom)

  forall (d in [x,y,z])
    ddt_mom_d  = - div(momBar_d * vBar) - grad pres 
  end forall

  ddt_rhot = -div(mom * pottBar)


  next_dens = ddt_dens * delta_t
  next_mom  = ddt_mom  * delta_t
  next_rhot = ddt_rhot * delta_t
end forall
