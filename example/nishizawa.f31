# 空間、時間刻みの定義
delta_x = 0.1
delta_y = 0.1
delta_z = 0.1
delta_t = 0.1

# 解像度の定義
nx = 100
ny = 100
nz = 100

# システムの独立変数の定義
@x = 0...NX
@y = 0...NY
@z = 0...NZ

@xh = @x + 1/2
@yh = @y + 1/2
@zh = (@z + 1/2)[0...NZ-1]

scalar dens[@x,@y,@z]
scalar rhot[@x,@y,@z]
vector(x,y,z) mom[ [@xh,@y,@z], [@x,@yh,@z], [@z,@y,@zh] ]

system s {dens, rhot, mom}


################################################################
# ライブラリ
################################################################
# 偏微分演算子
define vector(x,y,z) partial(a)
  ( a[i+1/2,j,k] - a[i-1/2,j,k] ) / delta_x,
  ( a[i,j+1/2,k] - a[i,j-1/2,k] ) / delta_y,
  ( a[i,j,k+1/2] - a[i,j,k-1/2] ) / delta_z
end define
    
# グラジエント演算子
define vector(x,y,z) grad(a)
  partial(a)
end define

# ダイバージェンス演算子
define scalar div(a)
  partial(a[x])[x] + partial(a[y])[y] + partial(a[z])[z] # 遅延実行されて余分な計算はされない
end define

# 2次と4次の補間関数の定義
define vector(x,y,z) interpolate2(a)
  ( a[i+1/2,j,k] + a[i-1/2,j,k] ) / 2, 
  ( a[i,j+1/2,k] + a[i,j-1/2,k] ) / 2,
  ( a[i,j,k+1/2] + a[i,j,k-1/2] ) / 2
end define
define vector(x,y,z) interpolate4(a)
  ( -a[i+3/2,j,k] + 7*a[i+1/2,j,k] + 7*a[i-1/2,j,k] - a[i-3/2,j,k] ) / 12,
  ( -a[i,j+3/2,k] + 7*a[i,j+1/2,k] + 7*a[i,j-1/2,k] - a[i,j-3/2,k] ) / 12,
  ( -a[i,j,k+3/2] + 7*a[i,j,k+1/2] + 7*a[i,j,k-1/2] - a[i,j,k-3/2] ) / 12
end define

# 配列をずらす演算子の定義(今回は使ってない)
define vector(x,y,z) <<(a,n)
  Rational, vector(x,y,z) :: n default [0,0,0]
  a[i+n[x],j+n[y],k+n[z]]
end define

################################################################
# 流体力学ソルバの実装
################################################################

# 4次の「ルンゲクッタ法」の定義
define rk4(op, phi)
  phi1 = phi + 1/4 * op(phi)
  phi2 = phi + 1/3 * op(phi1)
  phi3 = phi + 1/2 * op(phi2)
  phi4 = phi +       op(phi3)
  return phi4
end define

# 1次の時間発展オペレータの定義
# 現在の状態(current) から次の状態(next)を求める
define step1(current)
  pres = p00 * (current.rhot * rstar / p00) ** (cpstar / (cpstar - rstar))
  pott = current.rhot / current.dens

  vector(x,y,z) rhoBar [ [@xh,@y,@z], [@x,@yh,@z], [@x,@y,@zh] ]
  rhoBar  = interpolate2(rho)

  vector(x,y,z) vBar[ [@xh,@y,@z], [@x,@yh,@z], [@x,@y,@zh] ]
  vFullBar = current.mom / rhoBar

  scalar ddt_dens[@x,@y,@z] = - div(mom)

  vector(x,y,z) ddt_mom[ [@xh,@y,@z], [@x,@yh,@z], [@x,@y,@zh] ]

  vector(x,y,z) momBar[ [@x,@y,@z], [@xh,@yh,@z], [@xh,@y,@zh] ]
  vector(x,y,z) vBar[ [@x,@y,@z], [@xh,@yh,@z], [@xh,@y,@zh] ]
  momBar = interpolate4(mom[x])
  vBar[x] = interpolate2(vFullBar[x])[x]
  vBar[y] = interpolate2(vFullBar[y])[x]
  vBar[z] = interpolate2(vFullBar[z])[x]
  ddt_mom[x]  = - div(vBar * momBar) - grad(pres)[x]

  vector(x,y,z) momBar[ [@xh,@y,@z], [@x,@y,@z], [@x,@yh,@zh] ]
  vector(x,y,z) vBar[ [@xh,@y,@z], [@x,@y,@z], [@x,@yh,@zh] ]
  momBar = interpolate4(mom[y])
  vBar[x] = interpolate2(vFullBar[x])[y]
  vBar[y] = interpolate2(vFullBar[y])[y]
  vBar[z] = interpolate2(vFullBar[z])[y]
  ddt_mom[y]  = - div(vBar * momBar) - grad(pres)[y]

  vector(x,y,z) momBar[ [@x,@y,@zh], [@x,@yh,@zh], [@x,@y,@z] ]
  vector(x,y,z) vBar[ [@x,@y,@zh], [@x,@yh,@zh], [@x,@y,@z] ]
  momBar = interpolate4(mom[z])
  vBar[x] = interpolate2(vFullBar[x])[z]
  vBar[y] = interpolate2(vFullBar[y])[z]
  vBar[z] = interpolate2(vFullBar[z])[z]
  ddt_mom[z]  = - div(vBar * momBar) - grad(pres)[z]


  vector(x,y,z) pottBar [ [@xh,@y,@z], [@x,@yh,@z], [@x,@y,@zh] ]
  pottBar = interpolate4(pott)

  ddt_rhot = -div(current.mom * pottBar)

  system next

  next.dens = ddt_dens * delta_t
  next.mom  = ddt_mom  * delta_t
  next.rhot = ddt_rhot * delta_t

  return next
end define


# 初期条件
forall (i,j,k)
  s.dens[i,j,k] = exp(- k * delta_z / 50)
  s.rhot[i,j,k] = ( 273 - k * delta_z / 10 ) * s.dens[i,j,k]
end forall
s.mom = 0


# 時間発展
NT.times do 
  s = rk4(step1, s)
end
